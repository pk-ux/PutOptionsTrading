"""
User settings endpoints
- Portions generated by AI
"""

from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from sqlalchemy.orm import Session

from ...core.database import get_db
from ...core.deps import get_current_user, get_current_user_optional, is_admin
from ...models import User
from ...schemas.user import UserSettingsSchema, UserSettingsUpdate, UserInfo
from ...services.user import get_screens_remaining

router = APIRouter()


class AdminCheckResponse(BaseModel):
    is_admin: bool


@router.get("/me", response_model=UserInfo)
async def get_current_user_info(
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current user information including settings"""
    screens_remaining = get_screens_remaining(user)
    
    settings_dict = user.settings.to_dict() if user.settings else None
    settings_schema = UserSettingsSchema(**settings_dict) if settings_dict else None
    
    return UserInfo(
        id=user.id,
        email=user.email,
        subscription_status=user.subscription_status,
        screens_today=user.screens_today or 0,
        screens_remaining=screens_remaining,
        settings=settings_schema
    )


@router.get("/me/is-admin", response_model=AdminCheckResponse)
async def check_admin_status(
    user: User = Depends(get_current_user)
):
    """Check if current user has admin privileges"""
    return AdminCheckResponse(is_admin=is_admin(user))


@router.get("/settings", response_model=UserSettingsSchema)
async def get_settings(
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Get current user's settings"""
    if not user.settings:
        print(f"[Settings] User {user.id} has no settings, returning defaults")
        return UserSettingsSchema()
    
    settings_dict = user.settings.to_dict()
    print(f"[Settings] Returning settings for user {user.id}: symbols={settings_dict.get('symbols')}, max_prob={settings_dict.get('max_assignment_probability')}")
    return UserSettingsSchema(**settings_dict)


@router.put("/settings", response_model=UserSettingsSchema)
async def update_settings(
    settings_update: UserSettingsUpdate,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """Update current user's settings"""
    print(f"[Settings] PUT request from user {user.id}: {settings_update}")
    
    if not user.settings:
        raise HTTPException(status_code=404, detail="User settings not found")
    
    settings = user.settings
    
    # Update only provided fields (legacy fields)
    if settings_update.symbols is not None:
        settings.symbols = ",".join(settings_update.symbols)
        print(f"[Settings] Updated symbols to: {settings.symbols}")
    if settings_update.max_dte is not None:
        settings.max_dte = settings_update.max_dte
    if settings_update.min_dte is not None:
        settings.min_dte = settings_update.min_dte
    if settings_update.min_volume is not None:
        settings.min_volume = settings_update.min_volume
    if settings_update.min_open_interest is not None:
        settings.min_open_interest = settings_update.min_open_interest
    if settings_update.min_annualized_return is not None:
        settings.min_annualized_return = settings_update.min_annualized_return
    if settings_update.max_assignment_probability is not None:
        settings.max_assignment_probability = settings_update.max_assignment_probability
    
    # Update new fields (filter and trade idea selection)
    if settings_update.selected_filter_id is not None:
        settings.selected_filter_id = settings_update.selected_filter_id
        print(f"[Settings] Updated selected_filter_id to: {settings.selected_filter_id}")
    if settings_update.selected_trade_idea_id is not None:
        settings.selected_trade_idea_id = settings_update.selected_trade_idea_id
        print(f"[Settings] Updated selected_trade_idea_id to: {settings.selected_trade_idea_id}")
    
    db.commit()
    db.refresh(user)
    
    result = UserSettingsSchema(**user.settings.to_dict())
    print(f"[Settings] Saved and returning: symbols={result.symbols}, max_prob={result.max_assignment_probability}")
    return result
