"""
Options screening endpoints
- Portions generated by AI
"""

from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from ...core.database import get_db
from ...core.deps import get_current_user, get_current_user_optional
from ...core.config import get_settings
from ...models import User
from ...schemas.screen import ScreenRequest, ScreenResponse, NewsResponse, NewsItem
from ...services.screener import screen_symbols, get_news
from ...services.user import check_and_increment_usage

router = APIRouter()
settings = get_settings()


@router.post("/screen", response_model=ScreenResponse)
async def screen_options(
    request: ScreenRequest,
    user: User = Depends(get_current_user_optional),
    db: Session = Depends(get_db)
):
    """
    Screen options based on criteria.
    
    In Phase 1 (dev mode), this works without authentication.
    In Phase 2+, it will enforce usage limits for free tier users.
    """
    # Check symbol limits if user is authenticated
    if user:
        max_symbols = settings.PRO_MAX_SYMBOLS if user.subscription_status == "pro" else settings.FREE_MAX_SYMBOLS
        if len(request.symbols) > max_symbols:
            raise HTTPException(
                status_code=400,
                detail=f"Maximum {max_symbols} symbols allowed. Upgrade to Pro for more."
            )
        
        # Check and increment usage
        screens_remaining = check_and_increment_usage(db, user)
        if screens_remaining == 0 and user.subscription_status == "free":
            raise HTTPException(
                status_code=429,
                detail="Daily limit reached. Upgrade to Pro for unlimited screens."
            )
    else:
        screens_remaining = None
    
    # Perform screening
    results, used_yahoo = screen_symbols(
        symbols=request.symbols,
        max_dte=request.max_dte,
        min_dte=request.min_dte,
        min_volume=request.min_volume,
        min_open_interest=request.min_open_interest,
        min_annualized_return=request.min_annualized_return,
        max_assignment_probability=request.max_assignment_probability
    )
    
    return ScreenResponse(
        success=True,
        results=results,
        screens_remaining=screens_remaining if screens_remaining and screens_remaining >= 0 else None,
        used_yahoo_fallback=used_yahoo,
        message=f"Screened {len(results)} symbols successfully"
    )


@router.get("/news/{symbol}", response_model=NewsResponse)
async def get_ticker_news(
    symbol: str,
    limit: int = 10,
    max_age_days: int = 7
):
    """Get recent news for a ticker symbol"""
    news_items = get_news(symbol, limit=limit, max_age_days=max_age_days)
    
    return NewsResponse(
        symbol=symbol,
        news=[NewsItem(**item) for item in news_items] if news_items else []
    )


@router.get("/test-screen")
async def test_screen(symbol: str = "AAPL"):
    """
    Test endpoint - no auth required.
    Quick way to verify the screener logic works.
    """
    results, used_yahoo = screen_symbols(
        symbols=[symbol],
        max_dte=45,
        min_dte=15,
        min_volume=10,
        min_open_interest=10,
        min_annualized_return=20.0,
        max_assignment_probability=20
    )
    
    return {
        "symbol": symbol,
        "results_count": len(results.get(symbol, [])),
        "used_yahoo_fallback": used_yahoo,
        "top_results": results.get(symbol, [])[:5]
    }
