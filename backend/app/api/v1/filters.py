"""
Filter API endpoints
- Portions generated by AI
"""

from typing import List
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from ...core.database import get_db
from ...core.deps import get_current_user, get_current_user_optional, is_admin
from ...models import User, Filter
from ...schemas.filter import (
    FilterCreate,
    FilterUpdate,
    FilterResponse,
    FilterListResponse,
)

router = APIRouter()

# Maximum user filters allowed
MAX_USER_FILTERS = 10


def _filter_to_response(filter_obj: Filter) -> FilterResponse:
    """Convert Filter model to response schema"""
    return FilterResponse(
        id=filter_obj.id,
        name=filter_obj.name,
        is_system=filter_obj.is_system,
        is_default=filter_obj.is_default,
        user_id=filter_obj.user_id,
        min_dte=filter_obj.min_dte,
        max_dte=filter_obj.max_dte,
        min_volume=filter_obj.min_volume,
        min_open_interest=filter_obj.min_open_interest,
        min_annualized_return=filter_obj.min_annualized_return,
        max_assignment_probability=filter_obj.max_assignment_probability,
        created_at=filter_obj.created_at,
        updated_at=filter_obj.updated_at,
    )


@router.get("/filters", response_model=FilterListResponse)
async def list_filters(
    user: User = Depends(get_current_user_optional),
    db: Session = Depends(get_db)
):
    """
    List all filters available to the user.
    Returns system filters + user's own filters.
    """
    # Get all system filters
    system_filters = db.query(Filter).filter(Filter.is_system == True).all()
    
    # Get user's filters if authenticated
    user_filters = []
    if user:
        user_filters = db.query(Filter).filter(
            Filter.is_system == False,
            Filter.user_id == user.id
        ).all()
    
    # Find default filter ID
    default_filter = next((f for f in system_filters if f.is_default), None)
    default_filter_id = default_filter.id if default_filter else None
    
    return FilterListResponse(
        system_filters=[_filter_to_response(f) for f in system_filters],
        user_filters=[_filter_to_response(f) for f in user_filters],
        default_filter_id=default_filter_id,
    )


@router.get("/filters/{filter_id}", response_model=FilterResponse)
async def get_filter(
    filter_id: str,
    user: User = Depends(get_current_user_optional),
    db: Session = Depends(get_db)
):
    """Get a specific filter by ID."""
    filter_obj = db.query(Filter).filter(Filter.id == filter_id).first()
    
    if not filter_obj:
        raise HTTPException(status_code=404, detail="Filter not found")
    
    # Check access: system filters are public, user filters are private
    if not filter_obj.is_system and (not user or filter_obj.user_id != user.id):
        raise HTTPException(status_code=403, detail="Access denied")
    
    return _filter_to_response(filter_obj)


@router.post("/filters", response_model=FilterResponse)
async def create_filter(
    filter_data: FilterCreate,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Create a new user filter.
    Users can create up to 10 filters.
    """
    # Check user filter limit
    user_filter_count = db.query(Filter).filter(
        Filter.is_system == False,
        Filter.user_id == user.id
    ).count()
    
    if user_filter_count >= MAX_USER_FILTERS:
        raise HTTPException(
            status_code=400,
            detail=f"Maximum of {MAX_USER_FILTERS} user filters allowed"
        )
    
    # Generate name if not provided
    name = filter_data.name
    if not name:
        name = Filter.generate_name(
            filter_data.min_dte,
            filter_data.max_dte,
            filter_data.min_volume,
            filter_data.min_open_interest,
            filter_data.min_annualized_return,
            filter_data.max_assignment_probability,
        )
    
    # Create filter
    new_filter = Filter(
        name=name,
        is_system=False,
        is_default=False,
        user_id=user.id,
        min_dte=filter_data.min_dte,
        max_dte=filter_data.max_dte,
        min_volume=filter_data.min_volume,
        min_open_interest=filter_data.min_open_interest,
        min_annualized_return=filter_data.min_annualized_return,
        max_assignment_probability=filter_data.max_assignment_probability,
    )
    
    db.add(new_filter)
    db.commit()
    db.refresh(new_filter)
    
    return _filter_to_response(new_filter)


@router.put("/filters/{filter_id}", response_model=FilterResponse)
async def update_filter(
    filter_id: str,
    filter_data: FilterUpdate,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Update an existing user filter.
    Users can only update their own filters.
    """
    filter_obj = db.query(Filter).filter(Filter.id == filter_id).first()
    
    if not filter_obj:
        raise HTTPException(status_code=404, detail="Filter not found")
    
    # Only allow updating own filters (not system filters)
    if filter_obj.is_system:
        raise HTTPException(status_code=403, detail="Cannot modify system filters")
    
    if filter_obj.user_id != user.id:
        raise HTTPException(status_code=403, detail="Access denied")
    
    # Update fields
    update_data = filter_data.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(filter_obj, field, value)
    
    db.commit()
    db.refresh(filter_obj)
    
    return _filter_to_response(filter_obj)


@router.delete("/filters/{filter_id}")
async def delete_filter(
    filter_id: str,
    user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    """
    Delete a user filter.
    Users can only delete their own filters.
    """
    filter_obj = db.query(Filter).filter(Filter.id == filter_id).first()
    
    if not filter_obj:
        raise HTTPException(status_code=404, detail="Filter not found")
    
    # Only allow deleting own filters (not system filters)
    if filter_obj.is_system:
        raise HTTPException(status_code=403, detail="Cannot delete system filters")
    
    if filter_obj.user_id != user.id:
        raise HTTPException(status_code=403, detail="Access denied")
    
    db.delete(filter_obj)
    db.commit()
    
    return {"message": "Filter deleted successfully"}
