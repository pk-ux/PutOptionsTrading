"""
Caching layer with Redis support and in-memory fallback
- Portions generated by AI

Provides caching for:
- Stock prices (configurable TTL, default 3 minutes)
- Options chains (configurable TTL, default 5 minutes)
- News (configurable TTL, default 15 minutes)

Cache settings are loaded from database at app startup and stored in memory.
"""

import json
import hashlib
from typing import Any, Optional, Dict
from datetime import datetime, timedelta

# Try to import redis, fall back to in-memory if not available
try:
    import redis
    REDIS_AVAILABLE = True
except ImportError:
    REDIS_AVAILABLE = False
    print("Redis not installed. Using in-memory cache (not suitable for production).")

from .config import get_settings


# Default TTL values (used until settings are loaded from database)
DEFAULT_CACHE_SETTINGS: Dict[str, Any] = {
    "cache_enabled": True,
    "ttl_stock_price": 180,      # 3 minutes
    "ttl_options_chain": 300,    # 5 minutes
    "ttl_news": 900,             # 15 minutes
}

# In-memory cache settings (loaded from database at startup)
_cache_settings: Dict[str, Any] = DEFAULT_CACHE_SETTINGS.copy()


class InMemoryCache:
    """
    Simple in-memory cache for local development.
    NOT suitable for production with multiple workers.
    """
    
    def __init__(self):
        self._cache: dict[str, tuple[Any, datetime]] = {}
        print("Using in-memory cache (for local development only)")
    
    def get(self, key: str) -> Optional[str]:
        """Get value from cache if not expired"""
        if key in self._cache:
            value, expires_at = self._cache[key]
            if datetime.now() < expires_at:
                return value
            else:
                # Expired, remove it
                del self._cache[key]
        return None
    
    def set(self, key: str, value: str, ex: int = 300) -> None:
        """Set value with expiration (ex = seconds)"""
        expires_at = datetime.now() + timedelta(seconds=ex)
        self._cache[key] = (value, expires_at)
    
    def delete(self, key: str) -> None:
        """Delete a key from cache"""
        if key in self._cache:
            del self._cache[key]
    
    def flushall(self) -> None:
        """Clear all cached data"""
        self._cache.clear()
    
    def ping(self) -> bool:
        """Check if cache is available"""
        return True


class RedisCache:
    """
    Redis cache wrapper for production use.
    Supports multiple workers and horizontal scaling.
    """
    
    def __init__(self, redis_url: str):
        self._client = redis.from_url(redis_url, decode_responses=True)
        # Test connection
        try:
            self._client.ping()
            print(f"Connected to Redis successfully")
        except redis.ConnectionError as e:
            raise ConnectionError(f"Could not connect to Redis: {e}")
    
    def get(self, key: str) -> Optional[str]:
        """Get value from Redis"""
        return self._client.get(key)
    
    def set(self, key: str, value: str, ex: int = 300) -> None:
        """Set value with expiration (ex = seconds)"""
        self._client.set(key, value, ex=ex)
    
    def delete(self, key: str) -> None:
        """Delete a key from cache"""
        self._client.delete(key)
    
    def flushall(self) -> None:
        """Clear all cached data (use with caution!)"""
        self._client.flushall()
    
    def ping(self) -> bool:
        """Check if Redis is available"""
        try:
            self._client.ping()
            return True
        except:
            return False


# Global cache instance
_cache_instance: Optional[InMemoryCache | RedisCache] = None


def get_cache() -> InMemoryCache | RedisCache:
    """
    Get or create the cache instance.
    Uses Redis if REDIS_URL is configured, otherwise falls back to in-memory.
    """
    global _cache_instance
    
    if _cache_instance is not None:
        return _cache_instance
    
    settings = get_settings()
    redis_url = getattr(settings, 'REDIS_URL', None)
    
    if redis_url and REDIS_AVAILABLE:
        try:
            _cache_instance = RedisCache(redis_url)
            return _cache_instance
        except ConnectionError as e:
            print(f"Redis connection failed, falling back to in-memory: {e}")
    
    # Fallback to in-memory cache
    _cache_instance = InMemoryCache()
    return _cache_instance


def make_cache_key(prefix: str, *args, **kwargs) -> str:
    """
    Generate a consistent cache key from prefix and arguments.
    
    Example:
        make_cache_key("options", "AAPL", max_dte=45, min_dte=15)
        -> "options:AAPL:hash_of_kwargs"
    """
    key_parts = [prefix] + [str(a) for a in args]
    
    if kwargs:
        # Sort kwargs for consistent ordering
        sorted_kwargs = sorted(kwargs.items())
        kwargs_str = json.dumps(sorted_kwargs)
        kwargs_hash = hashlib.md5(kwargs_str.encode()).hexdigest()[:8]
        key_parts.append(kwargs_hash)
    
    return ":".join(key_parts)


# ============== Cache Settings Management ==============

def load_cache_settings_from_db() -> Dict[str, Any]:
    """
    Load cache settings from database into memory.
    Called at app startup. Creates default settings if none exist.
    """
    global _cache_settings
    
    from .database import SessionLocal
    from ..models.cache_settings import CacheSettings
    
    try:
        db = SessionLocal()
        settings = db.query(CacheSettings).filter(CacheSettings.id == 1).first()
        
        if not settings:
            # Create default settings
            settings = CacheSettings(
                id=1,
                cache_enabled=True,
                ttl_stock_price=180,
                ttl_options_chain=300,
                ttl_news=900,
            )
            db.add(settings)
            db.commit()
            db.refresh(settings)
            print("Created default cache settings in database")
        
        _cache_settings = settings.to_dict()
        print(f"Loaded cache settings: enabled={_cache_settings['cache_enabled']}, "
              f"ttl_stock={_cache_settings['ttl_stock_price']}s, "
              f"ttl_options={_cache_settings['ttl_options_chain']}s, "
              f"ttl_news={_cache_settings['ttl_news']}s")
        
        db.close()
        return _cache_settings
    except Exception as e:
        print(f"Error loading cache settings from database: {e}")
        print("Using default cache settings")
        return _cache_settings


def update_cache_settings_in_memory(settings: Dict[str, Any]) -> None:
    """
    Update the in-memory cache settings.
    Called when admin updates settings via API.
    """
    global _cache_settings
    _cache_settings = {
        "cache_enabled": settings.get("cache_enabled", True),
        "ttl_stock_price": settings.get("ttl_stock_price", 180),
        "ttl_options_chain": settings.get("ttl_options_chain", 300),
        "ttl_news": settings.get("ttl_news", 900),
        "updated_at": settings.get("updated_at"),
    }
    print(f"Updated in-memory cache settings: enabled={_cache_settings['cache_enabled']}")


def get_cache_settings() -> Dict[str, Any]:
    """Get current cache settings from memory."""
    return _cache_settings.copy()


def is_cache_disabled() -> bool:
    """Check if caching is disabled (from in-memory settings)."""
    return not _cache_settings.get("cache_enabled", True)


def get_ttl_stock_price() -> int:
    """Get TTL for stock price cache."""
    return _cache_settings.get("ttl_stock_price", 180)


def get_ttl_options_chain() -> int:
    """Get TTL for options chain cache."""
    return _cache_settings.get("ttl_options_chain", 300)


def get_ttl_news() -> int:
    """Get TTL for news cache."""
    return _cache_settings.get("ttl_news", 900)


# Convenience functions for common cache operations

def cache_get_json(key: str) -> Optional[Any]:
    """Get JSON value from cache"""
    if is_cache_disabled():
        return None
    cache = get_cache()
    value = cache.get(key)
    if value:
        try:
            return json.loads(value)
        except json.JSONDecodeError:
            return None
    return None


def cache_set_json(key: str, value: Any, ttl: int = 300) -> None:
    """Set JSON value in cache with TTL"""
    if is_cache_disabled():
        return
    cache = get_cache()
    cache.set(key, json.dumps(value), ex=ttl)


def get_cached_stock_price(symbol: str) -> Optional[float]:
    """Get cached stock price"""
    key = make_cache_key("price", symbol)
    return cache_get_json(key)


def set_cached_stock_price(symbol: str, price: float) -> None:
    """Cache stock price with configured TTL"""
    key = make_cache_key("price", symbol)
    cache_set_json(key, price, ttl=get_ttl_stock_price())


def get_cached_options_chain(symbol: str, config_hash: str) -> Optional[list]:
    """Get cached options chain"""
    key = make_cache_key("options", symbol, config_hash)
    return cache_get_json(key)


def set_cached_options_chain(symbol: str, config_hash: str, options: list) -> None:
    """Cache options chain with configured TTL"""
    key = make_cache_key("options", symbol, config_hash)
    cache_set_json(key, options, ttl=get_ttl_options_chain())


def get_cached_news(symbol: str) -> Optional[list]:
    """Get cached news"""
    key = make_cache_key("news", symbol)
    return cache_get_json(key)


def set_cached_news(symbol: str, news: list) -> None:
    """Cache news with configured TTL"""
    key = make_cache_key("news", symbol)
    cache_set_json(key, news, ttl=get_ttl_news())


def get_config_hash(config: dict) -> str:
    """Generate a hash for the config to use in cache keys"""
    config_str = json.dumps(config, sort_keys=True)
    return hashlib.md5(config_str.encode()).hexdigest()[:8]
