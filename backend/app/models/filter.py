"""
Filter database model for storing screening parameter presets
- Portions generated by AI
"""

import uuid
from datetime import datetime
from sqlalchemy import Column, String, Integer, Float, Boolean, DateTime, ForeignKey, Index
from sqlalchemy.orm import relationship

from ..core.database import Base


class Filter(Base):
    """Filter model for storing screening parameter presets"""
    __tablename__ = "filters"
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    name = Column(String(255), nullable=False)
    
    # System vs user filter
    is_system = Column(Boolean, default=False, nullable=False)
    is_default = Column(Boolean, default=False, nullable=False)  # Only one system filter can be default
    
    # Owner (null for system filters)
    user_id = Column(String(36), ForeignKey("users.id", ondelete="CASCADE"), nullable=True, index=True)
    
    # Screening parameters
    min_dte = Column(Integer, nullable=False)
    max_dte = Column(Integer, nullable=False)
    min_volume = Column(Integer, nullable=False)
    min_open_interest = Column(Integer, nullable=False)
    min_annualized_return = Column(Float, nullable=False)
    max_assignment_probability = Column(Integer, nullable=False)
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # Relationship
    user = relationship("User", back_populates="filters")
    
    # Index for efficient queries
    __table_args__ = (
        Index('idx_filters_system', 'is_system'),
        Index('idx_filters_default', 'is_system', 'is_default'),
    )
    
    def __repr__(self):
        return f"<Filter {self.name} (system={self.is_system})>"
    
    def to_dict(self) -> dict:
        """Convert filter to dictionary"""
        return {
            "id": self.id,
            "name": self.name,
            "is_system": self.is_system,
            "is_default": self.is_default,
            "user_id": self.user_id,
            "min_dte": self.min_dte,
            "max_dte": self.max_dte,
            "min_volume": self.min_volume,
            "min_open_interest": self.min_open_interest,
            "min_annualized_return": self.min_annualized_return,
            "max_assignment_probability": self.max_assignment_probability,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
    
    @staticmethod
    def generate_name(min_dte: int, max_dte: int, min_volume: int, min_open_interest: int,
                      min_annualized_return: float, max_assignment_probability: int) -> str:
        """Generate a descriptive name from filter parameters"""
        return f"DTE_{min_dte}-{max_dte}_VOL_{min_volume}_OI_{min_open_interest}_RET_{int(min_annualized_return)}_PROB_{max_assignment_probability}"
