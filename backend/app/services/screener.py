"""
Screener service - business logic for options screening
- Portions generated by AI
"""

import sys
import os
from typing import Dict, List, Any, Tuple

# Add shared module to path
shared_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", "..", "..", "shared"))
if shared_path not in sys.path:
    sys.path.insert(0, shared_path)

# Import from shared module
try:
    from options_screener import (
        get_stock_price_massive,
        get_stock_price_yahoo,
        get_options_chain_massive,
        get_options_chain_yahoo,
        calculate_metrics,
        screen_options as filter_options,
        format_output,
    )
    from massive_api_client import massive_client
    SCREENER_AVAILABLE = True
except ImportError as e:
    print(f"Warning: Could not import screener modules: {e}")
    SCREENER_AVAILABLE = False
    massive_client = None


def screen_symbols(
    symbols: List[str],
    max_dte: int = 45,
    min_dte: int = 15,
    min_volume: int = 10,
    min_open_interest: int = 10,
    min_annualized_return: float = 20.0,
    max_assignment_probability: int = 20,
) -> Tuple[Dict[str, List[Dict[str, Any]]], bool]:
    """
    Screen multiple symbols for put options.
    
    Args:
        symbols: List of stock symbols to screen
        max_dte: Maximum days to expiration
        min_dte: Minimum days to expiration
        min_volume: Minimum option volume
        min_open_interest: Minimum open interest
        min_annualized_return: Minimum annualized return percentage
        max_assignment_probability: Maximum assignment probability percentage
    
    Returns:
        Tuple of (results dict, used_yahoo_fallback bool)
        results dict: symbol -> list of option dicts
    """
    if not SCREENER_AVAILABLE:
        return {}, False
    
    # Build config for screener
    config = {
        'options_strategy': {
            'max_dte': max_dte,
            'min_dte': min_dte,
            'min_volume': min_volume,
            'min_open_interest': min_open_interest
        },
        'screening_criteria': {
            'min_annualized_return': min_annualized_return,
            'max_assignment_probability': max_assignment_probability
        },
        'output': {
            'sort_by': ['annualized_return'],
            'sort_order': 'descending',
            'max_results': 50
        }
    }
    
    results = {}
    used_yahoo = False
    
    for symbol in symbols:
        try:
            symbol_results, symbol_yahoo = _screen_single_symbol(symbol, config)
            if symbol_results:
                results[symbol] = symbol_results
            if symbol_yahoo:
                used_yahoo = True
        except Exception as e:
            print(f"Error processing {symbol}: {e}")
            continue
    
    return results, used_yahoo


def _screen_single_symbol(symbol: str, config: dict) -> Tuple[List[Dict[str, Any]], bool]:
    """
    Screen a single symbol for put options.
    
    Returns:
        Tuple of (list of option dicts, used_yahoo bool)
    """
    used_yahoo = False
    
    # Get price (Massive first, Yahoo fallback)
    current_price = get_stock_price_massive(symbol)
    if current_price is None:
        current_price = get_stock_price_yahoo(symbol)
        used_yahoo = True
    
    if current_price is None:
        return [], used_yahoo
    
    # Get options chain (Massive first, Yahoo fallback)
    options = get_options_chain_massive(symbol, config)
    if options.empty:
        options = get_options_chain_yahoo(symbol, config)
        if not options.empty:
            used_yahoo = True
    
    if options.empty:
        return [], used_yahoo
    
    # Calculate metrics and filter
    options = calculate_metrics(options, current_price)
    filtered = filter_options(options, config)
    formatted = format_output(filtered, current_price)
    
    if formatted.empty:
        return [], used_yahoo
    
    # Convert DataFrame to list of dicts
    return formatted.to_dict(orient='records'), used_yahoo


def get_news(symbol: str, limit: int = 10, max_age_days: int = 7) -> List[Dict[str, Any]]:
    """
    Get news for a symbol.
    
    Args:
        symbol: Stock symbol
        limit: Maximum number of news items
        max_age_days: Maximum age of news in days
    
    Returns:
        List of news item dicts
    """
    if not massive_client:
        return []
    
    try:
        return massive_client.get_ticker_news(symbol, limit=limit, max_age_days=max_age_days)
    except Exception as e:
        print(f"Error fetching news for {symbol}: {e}")
        return []
