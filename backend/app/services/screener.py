"""
Screener service - business logic for options screening
- Portions generated by AI

Includes caching layer for:
- Stock prices (1 minute TTL)
- Options chains (5 minutes TTL)
- News (15 minutes TTL)
"""

from typing import Dict, List, Any, Tuple

# Import from local modules
from .options_screener import (
    get_stock_price_massive,
    get_stock_price_yahoo,
    get_options_chain_massive,
    get_options_chain_yahoo,
    calculate_metrics,
    screen_options as filter_options,
    format_output,
)
from .massive_api_client import get_massive_client
from ..core.cache import (
    get_cached_stock_price,
    set_cached_stock_price,
    get_cached_options_chain,
    set_cached_options_chain,
    get_cached_news,
    set_cached_news,
    get_config_hash,
)

SCREENER_AVAILABLE = True


def screen_symbols(
    symbols: List[str],
    max_dte: int = 45,
    min_dte: int = 15,
    min_volume: int = 10,
    min_open_interest: int = 10,
    min_annualized_return: float = 20.0,
    max_assignment_probability: int = 20,
) -> Tuple[Dict[str, List[Dict[str, Any]]], bool]:
    """
    Screen multiple symbols for put options.
    
    Args:
        symbols: List of stock symbols to screen
        max_dte: Maximum days to expiration
        min_dte: Minimum days to expiration
        min_volume: Minimum option volume
        min_open_interest: Minimum open interest
        min_annualized_return: Minimum annualized return percentage
        max_assignment_probability: Maximum assignment probability percentage
    
    Returns:
        Tuple of (results dict, used_yahoo_fallback bool)
        results dict: symbol -> list of option dicts
    """
    if not SCREENER_AVAILABLE:
        return {}, False
    
    # Build config for screener
    config = {
        'options_strategy': {
            'max_dte': max_dte,
            'min_dte': min_dte,
            'min_volume': min_volume,
            'min_open_interest': min_open_interest
        },
        'screening_criteria': {
            'min_annualized_return': min_annualized_return,
            'max_assignment_probability': max_assignment_probability
        },
        'output': {
            'sort_by': ['annualized_return'],
            'sort_order': 'descending',
            'max_results': 50
        }
    }
    
    results = {}
    used_yahoo = False
    
    for symbol in symbols:
        try:
            symbol_results, symbol_yahoo = _screen_single_symbol(symbol, config)
            if symbol_results:
                results[symbol] = symbol_results
            if symbol_yahoo:
                used_yahoo = True
        except Exception as e:
            print(f"Error processing {symbol}: {e}")
            continue
    
    return results, used_yahoo


def _screen_single_symbol(symbol: str, config: dict) -> Tuple[List[Dict[str, Any]], bool]:
    """
    Screen a single symbol for put options.
    Uses caching to reduce external API calls.
    
    Returns:
        Tuple of (list of option dicts, used_yahoo bool)
    """
    import pandas as pd
    
    used_yahoo = False
    config_hash = get_config_hash(config)
    
    # Check cache for stock price first
    current_price = get_cached_stock_price(symbol)
    if current_price is not None:
        print(f"[CACHE HIT] Price for {symbol}: ${current_price}")
    else:
        # Get price from API (Massive first, Yahoo fallback)
        current_price = get_stock_price_massive(symbol)
        if current_price is None:
            current_price = get_stock_price_yahoo(symbol)
            used_yahoo = True
        
        if current_price is not None:
            # Cache the price for 1 minute
            set_cached_stock_price(symbol, current_price)
            print(f"[CACHE SET] Price for {symbol}: ${current_price}")
    
    if current_price is None:
        return [], used_yahoo
    
    # Check cache for options chain
    cached_options = get_cached_options_chain(symbol, config_hash)
    if cached_options is not None:
        print(f"[CACHE HIT] Options chain for {symbol} ({len(cached_options)} options)")
        options = pd.DataFrame(cached_options)
    else:
        # Get options chain from API (Massive first, Yahoo fallback)
        options = get_options_chain_massive(symbol, config)
        if options.empty:
            options = get_options_chain_yahoo(symbol, config)
            if not options.empty:
                used_yahoo = True
        
        if not options.empty:
            # Cache the raw options data for 5 minutes
            set_cached_options_chain(symbol, config_hash, options.to_dict(orient='records'))
            print(f"[CACHE SET] Options chain for {symbol} ({len(options)} options)")
    
    if options.empty:
        return [], used_yahoo
    
    # Calculate metrics and filter (always done fresh since these depend on current price)
    options = calculate_metrics(options, current_price)
    filtered = filter_options(options, config)
    formatted = format_output(filtered, current_price)
    
    if formatted.empty:
        return [], used_yahoo
    
    # Convert DataFrame to list of dicts
    return formatted.to_dict(orient='records'), used_yahoo


def get_news(symbol: str, limit: int = 10, max_age_days: int = 7) -> List[Dict[str, Any]]:
    """
    Get news for a symbol with caching.
    
    Args:
        symbol: Stock symbol
        limit: Maximum number of news items
        max_age_days: Maximum age of news in days
    
    Returns:
        List of news item dicts
    """
    # Check cache first
    cached_news = get_cached_news(symbol)
    if cached_news is not None:
        print(f"[CACHE HIT] News for {symbol} ({len(cached_news)} items)")
        return cached_news[:limit]  # Respect limit even from cache
    
    massive_client = get_massive_client()
    if not massive_client:
        return []
    
    try:
        news = massive_client.get_ticker_news(symbol, limit=limit, max_age_days=max_age_days)
        if news:
            # Cache news for 15 minutes
            set_cached_news(symbol, news)
            print(f"[CACHE SET] News for {symbol} ({len(news)} items)")
        return news
    except Exception as e:
        print(f"Error fetching news for {symbol}: {e}")
        return []
