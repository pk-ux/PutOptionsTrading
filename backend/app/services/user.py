"""
User service - business logic for user management
- Portions generated by AI
"""

from datetime import date
from typing import Optional
from sqlalchemy.orm import Session

from ..models.user import User, UserSettings
from ..core.config import DEFAULT_CONFIG, get_settings

settings = get_settings()


def get_or_create_user(db: Session, clerk_user_id: str, email: Optional[str] = None) -> User:
    """Get existing user or create new one with default settings"""
    user = db.query(User).filter(User.clerk_user_id == clerk_user_id).first()
    
    if not user:
        user = User(
            clerk_user_id=clerk_user_id,
            email=email,
            subscription_status="free",
            screens_today=0,
            last_screen_date=date.today()
        )
        db.add(user)
        db.commit()
        db.refresh(user)
        
        # Create default settings from config
        _create_default_settings(db, user)
        db.refresh(user)
        
    elif email and user.email != email:
        user.email = email
        db.commit()
    
    # Ensure settings exist for existing users
    if not user.settings:
        _create_default_settings(db, user)
        db.refresh(user)
    
    return user


def _create_default_settings(db: Session, user: User) -> UserSettings:
    """Create default settings for a user from config.json"""
    symbols = ",".join(DEFAULT_CONFIG.get('data', {}).get('symbols', ['AAPL', 'MSFT', 'GOOGL', 'SPY', 'QQQ']))
    opts = DEFAULT_CONFIG.get('options_strategy', {})
    criteria = DEFAULT_CONFIG.get('screening_criteria', {})
    
    user_settings = UserSettings(
        user_id=user.id,
        symbols=symbols,
        max_dte=opts.get('max_dte', 45),
        min_dte=opts.get('min_dte', 15),
        min_volume=opts.get('min_volume', 10),
        min_open_interest=opts.get('min_open_interest', 10),
        min_annualized_return=criteria.get('min_annualized_return', 20.0),
        max_assignment_probability=criteria.get('max_assignment_probability', 20)
    )
    db.add(user_settings)
    db.commit()
    return user_settings


def get_user_by_email(db: Session, email: str) -> Optional[User]:
    """Get user by email"""
    return db.query(User).filter(User.email == email).first()


def check_and_increment_usage(db: Session, user: User) -> int:
    """
    Check usage limits and increment counter.
    Returns remaining screens or -1 for unlimited (pro users).
    """
    today = date.today()
    
    # Reset counter if new day
    if user.last_screen_date != today:
        user.screens_today = 0
        user.last_screen_date = today
    
    # Check limits for free tier
    if user.subscription_status == "free":
        remaining = settings.FREE_SCREENS_PER_DAY - user.screens_today - 1
        if remaining < 0:
            return 0  # Limit reached
    else:
        remaining = -1  # Unlimited for pro
    
    # Increment usage
    user.screens_today += 1
    db.commit()
    
    return remaining


def get_screens_remaining(user: User) -> int:
    """Get remaining screens for user"""
    today = date.today()
    screens_today = user.screens_today if user.last_screen_date == today else 0
    
    if user.subscription_status == "free":
        return max(0, settings.FREE_SCREENS_PER_DAY - screens_today)
    return -1  # Unlimited
