"""
Tests for Massive API Client
- Portions generated by AI

Run with: python test_massive_api_client.py
Or with pytest: pytest test_massive_api_client.py -v
"""

import os
import sys
import unittest
from datetime import datetime, timedelta

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))


class TestMassiveAPIClient(unittest.TestCase):
    """Test cases for MassiveAPIClient class."""
    
    @classmethod
    def setUpClass(cls):
        """Set up test fixtures - runs once before all tests."""
        # Load environment variables
        env_file = os.path.join(os.path.dirname(__file__), '.env')
        if os.path.exists(env_file):
            with open(env_file) as f:
                for line in f:
                    if '=' in line and not line.startswith('#'):
                        key, value = line.strip().split('=', 1)
                        os.environ[key] = value
        
        # Import after env is loaded
        from massive_api_client import massive_client
        cls.client = massive_client
        
        # Test configuration
        cls.test_config = {
            'options_strategy': {
                'max_dte': 45,
                'min_dte': 7,
                'min_volume': 10,
                'min_open_interest': 10
            },
            'screening_criteria': {
                'min_annualized_return': 20,
                'max_assignment_probability': 20
            },
            'output': {
                'sort_by': ['annualized_return'],
                'sort_order': 'descending',
                'max_results': 50
            }
        }
        
        # Test symbols
        cls.test_symbol = 'AAPL'
        cls.test_symbols = ['AAPL', 'AMD', 'MSFT']
    
    def test_01_client_initialization(self):
        """Test that the Massive API client initializes correctly."""
        self.assertIsNotNone(self.client, "Massive client should be initialized")
        self.assertIsNotNone(self.client.api_key, "API key should be set")
        self.assertIsNotNone(self.client.client, "RESTClient should be initialized")
        print("✓ Client initialization: PASSED")
    
    def test_02_get_stock_price(self):
        """Test fetching stock price from Yahoo Finance."""
        price = self.client.get_stock_price(self.test_symbol)
        
        self.assertIsNotNone(price, f"Price for {self.test_symbol} should not be None")
        self.assertIsInstance(price, float, "Price should be a float")
        self.assertGreater(price, 0, "Price should be positive")
        
        print(f"✓ Stock price for {self.test_symbol}: ${price:.2f} - PASSED")
    
    def test_03_get_stock_quote(self):
        """Test get_stock_quote returns correct format."""
        quote = self.client.get_stock_quote(self.test_symbol)
        
        self.assertIsInstance(quote, dict, "Quote should be a dictionary")
        self.assertIn('success', quote, "Quote should have 'success' key")
        self.assertTrue(quote['success'], "Quote should be successful")
        self.assertIn('symbol', quote, "Quote should have 'symbol' key")
        self.assertIn('last_price', quote, "Quote should have 'last_price' key")
        self.assertEqual(quote['symbol'], self.test_symbol, "Symbol should match")
        
        print(f"✓ Stock quote for {self.test_symbol}: ${quote['last_price']:.2f} - PASSED")
    
    def test_04_get_options_chain_returns_dataframe(self):
        """Test that get_options_chain returns a DataFrame."""
        import pandas as pd
        
        options = self.client.get_options_chain(self.test_symbol, self.test_config)
        
        self.assertIsInstance(options, pd.DataFrame, "Should return a DataFrame")
        self.assertFalse(options.empty, "DataFrame should not be empty")
        
        print(f"✓ Options chain returns DataFrame with {len(options)} rows - PASSED")
    
    def test_05_options_chain_has_required_columns(self):
        """Test that options chain has all required columns."""
        options = self.client.get_options_chain(self.test_symbol, self.test_config)
        
        required_columns = [
            'symbol', 'strike', 'expiry', 'dte', 'volume', 'open_interest',
            'lastPrice', 'price_source', 'impliedVolatility', 'delta',
            'gamma', 'theta', 'vega', 'contract_symbol'
        ]
        
        for col in required_columns:
            self.assertIn(col, options.columns, f"Column '{col}' should be present")
        
        print(f"✓ Options chain has all {len(required_columns)} required columns - PASSED")
    
    def test_06_options_chain_price_source_is_last_trade(self):
        """Test that options prices come from last_trade (upgraded API)."""
        options = self.client.get_options_chain(self.test_symbol, self.test_config)
        
        # Count price sources
        price_sources = options['price_source'].value_counts()
        
        self.assertIn('last_trade', price_sources.index, 
                      "Should have options with last_trade price source")
        
        last_trade_pct = price_sources.get('last_trade', 0) / len(options) * 100
        
        print(f"✓ Price sources: {dict(price_sources)}")
        print(f"✓ last_trade: {last_trade_pct:.1f}% of options - PASSED")
    
    def test_07_options_chain_has_valid_greeks(self):
        """Test that Greeks are present and valid."""
        options = self.client.get_options_chain(self.test_symbol, self.test_config)
        
        # Check delta is in valid range for puts (-1 to 0)
        self.assertTrue((options['delta'] <= 0).all(), "Put delta should be <= 0")
        self.assertTrue((options['delta'] >= -1).all(), "Put delta should be >= -1")
        
        # Check theta is negative (time decay)
        self.assertTrue((options['theta'] <= 0).all(), "Theta should be <= 0 (time decay)")
        
        # Check gamma and vega are non-negative
        self.assertTrue((options['gamma'] >= 0).all(), "Gamma should be >= 0")
        self.assertTrue((options['vega'] >= 0).all(), "Vega should be >= 0")
        
        print("✓ Greeks validation (delta, theta, gamma, vega) - PASSED")
    
    def test_08_options_chain_respects_dte_filter(self):
        """Test that options respect min/max DTE filters."""
        options = self.client.get_options_chain(self.test_symbol, self.test_config)
        
        min_dte = self.test_config['options_strategy']['min_dte']
        max_dte = self.test_config['options_strategy']['max_dte']
        
        self.assertTrue((options['dte'] >= min_dte).all(), 
                        f"All options should have DTE >= {min_dte}")
        self.assertTrue((options['dte'] <= max_dte).all(), 
                        f"All options should have DTE <= {max_dte}")
        
        print(f"✓ DTE filter ({min_dte}-{max_dte} days) - PASSED")
    
    def test_09_options_chain_has_valid_prices(self):
        """Test that option prices are valid."""
        options = self.client.get_options_chain(self.test_symbol, self.test_config)
        
        # All prices should be positive
        self.assertTrue((options['lastPrice'] > 0).all(), "All prices should be positive")
        
        # Strikes should be positive
        self.assertTrue((options['strike'] > 0).all(), "All strikes should be positive")
        
        # IV should be positive
        self.assertTrue((options['impliedVolatility'] > 0).all(), "IV should be positive")
        
        print("✓ Price validation (lastPrice, strike, IV all positive) - PASSED")
    
    def test_10_get_ticker_news(self):
        """Test fetching ticker news."""
        news = self.client.get_ticker_news(self.test_symbol, limit=5, max_age_days=30)
        
        self.assertIsInstance(news, list, "News should be a list")
        
        if len(news) > 0:
            # Check news item structure
            item = news[0]
            self.assertIn('title', item, "News item should have 'title'")
            self.assertIn('url', item, "News item should have 'url'")
            self.assertIn('date_display', item, "News item should have 'date_display'")
            print(f"✓ Ticker news: {len(news)} items retrieved - PASSED")
        else:
            print("✓ Ticker news: No recent news (this is acceptable) - PASSED")
    
    def test_11_multiple_symbols(self):
        """Test fetching options for multiple symbols."""
        for symbol in self.test_symbols:
            options = self.client.get_options_chain(symbol, self.test_config)
            self.assertFalse(options.empty, f"Options for {symbol} should not be empty")
            
            # Verify price source
            last_trade_count = (options['price_source'] == 'last_trade').sum()
            print(f"  {symbol}: {len(options)} options, {last_trade_count} with last_trade price")
        
        print(f"✓ Multiple symbols ({', '.join(self.test_symbols)}) - PASSED")
    
    def test_12_invalid_symbol_handling(self):
        """Test handling of invalid symbol."""
        import pandas as pd
        
        options = self.client.get_options_chain('INVALID_SYMBOL_XYZ123', self.test_config)
        
        # Should return empty DataFrame, not raise exception
        self.assertIsInstance(options, pd.DataFrame, "Should return DataFrame for invalid symbol")
        
        print("✓ Invalid symbol handling - PASSED")


def run_tests():
    """Run all tests and print summary."""
    print("=" * 70)
    print("MASSIVE API CLIENT - TEST SUITE")
    print("=" * 70)
    print()
    
    # Create test suite
    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(TestMassiveAPIClient)
    
    # Run tests with verbosity
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Print summary
    print()
    print("=" * 70)
    print("TEST SUMMARY")
    print("=" * 70)
    print(f"Tests run: {result.testsRun}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")
    print(f"Skipped: {len(result.skipped)}")
    
    if result.wasSuccessful():
        print("\n*** ALL TESTS PASSED ***")
        return 0
    else:
        print("\n*** SOME TESTS FAILED ***")
        for test, traceback in result.failures + result.errors:
            print(f"\nFailed: {test}")
            print(traceback)
        return 1


if __name__ == '__main__':
    sys.exit(run_tests())
